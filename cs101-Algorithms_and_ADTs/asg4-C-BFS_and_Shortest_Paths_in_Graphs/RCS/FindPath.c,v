head	1.10;
access;
symbols;
locks;
comment	@ * @;


1.10
date	2010.11.15.03.42.28;	author dmfrank;	state -;
branches;
next	1.9;

1.9
date	2010.11.15.03.40.45;	author dmfrank;	state -;
branches;
next	1.8;

1.8
date	2010.11.15.03.30.00;	author dmfrank;	state -;
branches;
next	1.7;

1.7
date	2010.11.15.03.09.29;	author dmfrank;	state -;
branches;
next	1.6;

1.6
date	2010.11.15.02.13.56;	author dmfrank;	state -;
branches;
next	1.5;

1.5
date	2010.11.15.02.10.35;	author dmfrank;	state -;
branches;
next	1.4;

1.4
date	2010.11.15.00.28.48;	author dmfrank;	state -;
branches;
next	1.3;

1.3
date	2010.11.15.00.15.24;	author dmfrank;	state -;
branches;
next	1.2;

1.2
date	2010.11.15.00.13.50;	author dmfrank;	state -;
branches;
next	1.1;

1.1
date	2010.11.14.23.36.05;	author dmfrank;	state -;
branches;
next	;


desc
@@


1.10
log
@-
@
text
@/*******************************************************************************
 *  $Id: FindPath.c,v 1.14 2010-11-14 19:29:24-08 dmfrank - $
 *	Derek Frank, dmfrank@@ucsc.edu
 *	
 *	NAME
 *	  FindPath.c
 *  
 *	DESCRIPTION
 *	  The main class of the program FindPath that implements both the Graph and
 *	List ADTs.  First reads an input file containing a graph on n vertices with
 *	specified edges.  It then prints the graph's adjacency list.  Next it goes
 *	on a loop to read in a source and destination from the input file, then uses
 *	the Breadth First Search algorithm to make a tree of shortest paths given
 *	the source from the input file and prints out the distance and shortest path
 *	from the source to the given destination.
 ******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Graph.h"

#define MAX_LEN 250

/* boolean type definition */
typedef enum {FALSE = 0, TRUE = 1} bool;

void printDestandPath(FILE* out, GraphRef G, ListRef path, int dest) {
	fprintf(out, "The distance from %d to %d is ", getSource(G), dest);
	if ( getFront(path) == NIL ) {
		fprintf(out, "infinity\n");
		fprintf(out, "No %d-%d path exists", getSource(G), dest);
	}else {
		fprintf(out, "%d\n", getDist(G, dest));
		fprintf(out, "A shortest %d-%d path is: ", getSource(G), dest);
		printList(out, path);
	}
	fprintf(out,"\n");
}

int main (int argc, char * argv[]) {
	/* check command line for correct number of arguments */
	if( argc != 3 ){
		printf("Usage: %s infile outfile\n", argv[0]);
		exit(1);
	}
	
	/* open files for reading and writing */
	FILE *in, *out;
	in = fopen(argv[1], "r");
	out = fopen(argv[2], "w");
	if( in==NULL ) {
		printf("Unable to open file %s for reading\n", argv[1]);
		exit(1);
	}
	if( out==NULL ) {
		printf("Unable to open file %s for writing\n", argv[2]);
		exit(1);
	}
	
	/* declare and initialize variables */
	char line[MAX_LEN];
	char* token;
	int linenum = 0;
	bool flag = FALSE;
	int  n, x, y, source, dest;
	GraphRef G;
	ListRef path = newList();
	
	/* read and store the graph and print out its adjacency list */
	while( !flag && fgets(line, MAX_LEN, in) != NULL ) {
		++linenum;
		token = strtok(line, " \n");
		if( linenum == 1 ) {
			n = atoi(token);
			G = newGraph(n);
		}else {
			x = atoi(token);
			token = strtok(NULL, " \n");
			y = atoi(token);
			if( x != 0 ) {
				addEdge(G, x, y);
			}
			else { flag = TRUE; }
		}
	}
	printGraph(out, G);
	fprintf(out, "\n");
	
	/* read in pair of vertices, run BFS on source vertex, print the distance
	 * to the destination vertex, then find and print the resulting shortest
	 * path, it if exists, or print a message if no path from source to
	 * destination exists */
	while( fgets(line, MAX_LEN, in) != NULL ) {
		token = strtok(line, " \n");
		source = atoi(token);
		token = strtok(NULL, " \n");
		dest = atoi(token);
		if( source != NIL ){
			BFS(G, source);
			makeEmpty(path);
			getPath(path, G, dest);
			printDestandPath(out, G, path, dest);
		}
	}
	
	/* free memory */
	freeList(&path);
	freeGraph(&G);
	
	/* close files */
	fclose(in);
	fclose(out);

	return(0);
}
@


1.9
log
@-
@
text
@d52 1
a52 1
	if( in==NULL ){
d56 1
a56 1
	if( out==NULL ){
d71 1
a71 1
	while( !flag && fgets(line, MAX_LEN, in) != NULL )  {
@


1.8
log
@-
@
text
@d25 1
d61 1
@


1.7
log
@-
@
text
@d2 1
a2 1
 *  $Id: FindPath.c,v 1.12 2010-11-14 18:13:26-08 dmfrank - $
d9 7
a15 2
 *	  The main class of the program FindPath that implements the Graph and
 *	List ADTs to .
@


1.6
log
@-
@
text
@d15 1
d64 1
a64 1
	while( fgets(line, MAX_LEN, in) != NULL && !flag )  {
d67 1
a67 1
		if( linenum == 0 ) {
a73 1
			token = strtok(NULL, " \n");
d77 1
a77 1
			else { flag == TRUE; }
d88 1
d91 1
a91 2
		destination = atoi(token);
		token = strtok(NULL, " \n");
@


1.5
log
@-
@
text
@d2 1
a2 1
 *  $Id: FindPath.c,v 1.10 2010-11-14 18:00:46-08 dmfrank - $
d54 1
a54 1
	char line[MAX_LEN]
d60 1
a60 1
	ListRef path = newPath();
@


1.4
log
@-
@
text
@d2 1
a2 1
 *  $Id: FindPath.c,v 1.8 2010-11-14 15:03:40-08 dmfrank - $
d17 5
a21 2
void printPath(FILE* out, GraphRef G, ListRef path, int dest){
	fprintf(out,"\n");
a34 2
	FILE *in, *out;
	
d42 1
d54 26
a79 13
	int n = 7;
	int dest;
	GraphRef G = newGraph(n);
	ListRef path = newList();
	
	addEdge(G, 1, 4);
	addEdge(G, 1, 5);
	addEdge(G, 4, 5);
	addEdge(G, 2, 3);
	addEdge(G, 2, 6);
	addEdge(G, 3, 7);
	addEdge(G, 6, 7);
	
d81 1
d83 16
a98 17
	BFS(G, 2);
	dest = 7;
	getPath(path, G, dest);
	printPath(out, G, path, dest);

	
	BFS(G, 3);
	makeEmpty(path);
	dest = 6;
	getPath(path, G, dest);
	printPath(out, G, path, dest);
	
	BFS(G, 1);
	makeEmpty(path);
	dest = 7;
	getPath(path, G, dest);
	printPath(out, G, path, dest);
d100 1
d107 1
a107 74
	
/*
	int i, n, temp, order, numberOfP;
	int count=0;
	FILE *in, *out;
	char line[MAX_LEN];
	char* token;
	ListRef permutation = newList();
	ListRef list = newList();
	ListRef copy = NULL;
*/
	/* check command line for correct number of arguments */
/*	if( argc != 3 ){
		printf("Usage: %s infile outfile\n", argv[0]);
		exit(1);
	}
*/	
	/* open files for reading and writing */
/*	in = fopen(argv[1], "r");
	out = fopen(argv[2], "w");
	if( in==NULL ){
		printf("Unable to open file %s for reading\n", argv[1]);
		exit(1);
	}
	if( out==NULL ){
		printf("Unable to open file %s for writing\n", argv[2]);
		exit(1);
	}
*/
	/* read each line of input file, then place tokens in list
	 * and shuffle until the list is back to its original state */
/*	while( fgets(line, MAX_LEN, in) != NULL)  {
		count++;
		order = 0;
		n = 0;
		token = strtok(line, " \n");
		while( token!=NULL ){
			temp = atoi(token);
			n++;
			insertAfterBack(permutation, temp);
			token = strtok(NULL, " \n");
		}
		if (count == 1) {
			numberOfP = temp;
		}else {
			for ( i=1; i<=getLength(permutation); ++i) {
				insertAfterBack(list, i);
			}
			
			copy = copyList(list);
			shuffle(list, permutation);
			++order;
			printList(out, list);
			
			while ( !equals(list, copy) ) {
				shuffle(list, permutation);
				++order;
			}
			
			fprintf(out," order= %d\n", order);
			makeEmpty(list);
			freeList(&copy);
			copy = NULL;
		}
		makeEmpty(permutation);
	}
	
	freeList(&permutation);
	freeList(&list);
*/	
	/* close files */
/*	fclose(in);
	fclose(out);
*/
@


1.3
log
@-
@
text
@d17 1
a17 1
void printPath(FILE* out, GraphRef G, ListRef path){
d19 1
a19 1
	fprintf(out, "The distance from %d to %d is ", getSource(G), getBack(path));
d22 1
a22 1
		fprintf(out, "No %d-%d path exists", getSource(G), getBack(path));
d24 2
a25 2
		fprintf(out, "%d\n", getLength(path));
		fprintf(out, "A shortest %d-%d path is: ", getSource(G), getBack(path));
d53 1
d68 3
a70 2
	getPath(path, G, 7);
	printPath(out, G, path);
d72 1
d75 3
a77 2
	getPath(path, G, 7);
	printPath(out, G, path);
d81 3
a83 2
	getPath(path, G, 7);
	printPath(out, G, path);
@


1.2
log
@-
@
text
@d54 1
a54 1
	ListRef path = newList():
d67 1
a67 1
	getPath(L, G, 7);
d72 1
a72 1
	getPath(L, G, 7);
d77 1
a77 1
	getPath(L, G, 7);
@


1.1
log
@-
@
text
@d2 1
a2 1
 *  $Id: FindPath.c,v 1.1 2010-11-14 15:03:36-08 dmfrank - $
d17 14
d54 1
d63 3
d67 12
a78 3
	printGraph(out, G);
	/*BFS(G, 3);
	BFS(G, 1);*/
d80 1
@
