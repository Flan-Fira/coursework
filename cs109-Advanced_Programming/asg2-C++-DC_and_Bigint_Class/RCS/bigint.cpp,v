head	1.10;
access;
symbols;
locks;
comment	@// @;


1.10
date	2012.12.05.03.40.04;	author -;	state -;
branches;
next	1.9;

1.9
date	2012.12.05.03.38.03;	author -;	state -;
branches;
next	1.8;

1.8
date	2011.02.01.19.41.16;	author dmfrank;	state -;
branches;
next	1.7;

1.7
date	2011.02.01.19.26.12;	author dmfrank;	state -;
branches;
next	1.6;

1.6
date	2011.02.01.18.38.30;	author dmfrank;	state -;
branches;
next	1.5;

1.5
date	2011.02.01.17.04.56;	author dmfrank;	state -;
branches;
next	1.4;

1.4
date	2011.02.01.07.20.08;	author dmfrank;	state -;
branches;
next	1.3;

1.3
date	2011.01.31.14.22.52;	author dmfrank;	state -;
branches;
next	1.2;

1.2
date	2011.01.29.23.35.40;	author dmfrank;	state -;
branches;
next	1.1;

1.1
date	2011.01.20.01.34.49;	author dmfrank;	state -;
branches;
next	;


desc
@@


1.10
log
@-
@
text
@/* $Id: bigint.cpp,v 1.9 2012-12-04 19:38:03-08 - - $
 * Derek Frank, dmfrank@@ucsc.edu
 *
 * NAME
 *   bigint
 *
 * DESCRIPTION
 *
 */

#include <cstdlib>
#include <exception>
#include <limits>
#include <climits>
#include <stack>
#include <stdexcept>

using namespace std;

#include "bigint.h"
#include "trace.h"

//
// ctor
//    initializes and empty bigint
//
bigint::bigint (): negative (false), big_value (new bigvalue_t ()) {
}

//
// ctor
//    copies bigint parameter values and sets this equal to them
//
bigint::bigint (const bigint &that): negative (false), 
                  big_value (new bigvalue_t (*that.big_value)) {
                     
   this->negative = that.negative;
}

//
// operator=
//    first checks if this is equal to the bigint parameter.  if not,
//    then deletes the current values for this.  next copies the bigint
//    parameter values and sets this equal to them
//
bigint &bigint::operator= (const bigint &that) {
   if (this == &that) return *this;
   
   delete this->big_value;
   this->negative = that.negative;
   this->big_value = new bigvalue_t (*that.big_value);
   return *this;
}

//
// dtor
//    uses delete on any fields that used new
//
bigint::~bigint() {
   TRACE ('~', cout << *this);
   delete this->big_value;
}

//
// ctor
//    creates a bigint by converting an int to a bigvalue_t
//
bigint::bigint (int that): negative (false),
                  big_value (new bigvalue_t ()) {

   unsigned char currc;
   if (that == 0) {
      currc = '0';
      this->big_value->push_back (currc);
   }else {
      if (that < 0) {
         this->negative = true;
         that *= -1;
      }
      int curr = 0;
      int num = that;
      while (num != 0) {
         curr = num % 10;
         num -= curr;
         num /= 10;
         currc = curr + '0';
         this->big_value->push_back (currc);
      }
   }
}

//
// ctor
//    inserts a string as a bigint value by first checking the sign of
//    the string, then pushes each char starting from the back of the
//    string onto the bigvalue_t
//
bigint::bigint (const string &that): negative (false),
                  big_value (new bigvalue_t ()) {
   TRACE ('b', that);

   string::const_iterator itor = that.end ();
   string::const_iterator begin = that.begin ();
   if (*begin == '_') {
      this->negative = true;
      ++begin;
   }
   char currc;
   for (; itor != begin; --itor) {
      currc = *itor;
      this->big_value->push_back (currc);
   }
   currc = *begin;
   this->big_value->push_back (currc);
}

//
// operator+
//    the addition of bigints operator.  if both bigints have the same
//    sign, then calls do_bigadd() to add the vectors.  if the signs are
//    different, then calls abs_compare() to determine the larger number
//    and lastly calls do_bigsub() to subtract the larger minus the
//    smaller.  returns a bigint
//
bigint bigint::operator+ (const bigint &that) const {
   bigint bigsum;
   TRACE ('p', bigsum);
   
   if (this->negative == that.negative) {
      bigsum = (*this).do_bigadd (that);
   }else {
      if ((*this).abscompare (that) == 1) {
         bigsum = (*this).do_bigsub (that);
      }else if ((*this).abscompare (that) == -1) {
         bigsum = that.do_bigsub (*this);
      }else {
         bigsum.big_value->push_back ('0');
      }
   }
   return bigsum;
}

//
// operator-
//    the subtraction of that from this operator for bigints.  if this
//    and that have opposite signs, then calls do_bigadd() to add the
//    vectors since the subtraction turns this operation into addition.
//    if the signs are the same, then calls abs_compare() to determine
//    the dominating number and lastly calls do_bigsub() to subtract
//    the larger minus the smaller.  returns a bigint
//
bigint bigint::operator- (const bigint &that) const {
   bigint bigdiff;
   TRACE ('m', bigdiff);

   if (this->negative != that.negative) {
      bigdiff = (*this).do_bigadd (that);
   }else {
      if ((*this).abscompare (that) == 1) {
         bigdiff = (*this).do_bigsub (that);
      }else if ((*this).abscompare (that) == -1) {
         bigdiff = that.do_bigsub (*this);
         bigdiff.negative = !that.negative;
      }else {
         bigdiff.big_value->push_back ('0');
      }
   }
   return bigdiff;
}

//
// operator-
//    changes the sign of this bigint to its opposite
//
bigint bigint::operator- () const {
   bigint opp_val = (*this);
   opp_val.negative = !opp_val.negative;
   return opp_val;
}

//
// compare
//    compares two vectors.  first compares signs, then compares size of
//    vectors, and finally compares the individual digits starting with
//    the most significant.  returns -1 if this is smaller than that, 1
//    if this is bigger than that, and 0 if this equals that
//
int bigint::compare (const bigint &that) const {
   if (this->negative == true && that.negative == false) {
      return -1;
   }else if (this->negative == false && that.negative == true) {
      return 1;
   }else if ((this->negative == that.negative) == true) {
      if (this->big_value->size () < that.big_value->size ()) {
         return 1;
      }else if (this->big_value->size () > that.big_value->size ()) {
         return -1;
      }else {
         vector<bigint::digit_t>::const_iterator thisitor, thatitor;
         thisitor = this->big_value->begin ();
         thatitor = that.big_value->begin ();
         unsigned char thisc, thatc;
         for (int i = this->big_value->size () - 1; i >= 0; --i) {
            thisc = *thisitor;
            thatc = *thatitor;
            if (thisc < thatc) {
               return 1;
            }else if (thisc > thatc) {
               return -1;
            }
            ++thisitor;
            ++thatitor;
         }
      }
   }else {
      if (this->big_value->size () < that.big_value->size ()) {
         return -1;
      }else if (this->big_value->size () > that.big_value->size ()) {
         return 1;
      }else {
         vector<bigint::digit_t>::const_iterator thisitor, thatitor;
         thisitor = this->big_value->begin ();
         thatitor = that.big_value->begin ();
         unsigned char thisc, thatc;
         for (int i = this->big_value->size () - 1; i >= 0; --i) {
            thisc = *thisitor;
            thatc = *thatitor;
            if (thisc < thatc) {
               return -1;
            }else if (thisc > thatc) {
               return 1;
            }
            ++thisitor;
            ++thatitor;
         }
      }
   }
   return 0;
}

//
// abscompare
//    compares the absolute value of two vectors.  first compares size
//    of the vectors, then compares the absolute value of individual
//    digits starting with the most significant.  returns -1 if this is
//    smaller than that, 1 if this is bigger than that, and 0 if this
//    equals that.
//
int bigint::abscompare (const bigint &that) const {
   if (this->big_value->size () < that.big_value->size ()) {
      return -1;
   }else if (this->big_value->size () > that.big_value->size ()) {  
      return 1;
   }else {
      vector<bigint::digit_t>::const_iterator thisitor, thatitor;
      thisitor = this->big_value->begin ();
      thatitor = that.big_value->begin ();
      unsigned char thisc, thatc;
      for (int i = this->big_value->size () - 1; i >= 0; --i) {
         thisc = *thisitor;
         thatc = *thatitor;
         if (thisc < thatc) {
            return -1;
         }else if (thisc > thatc) {
            return 1;
         }
         --thisitor;
         --thatitor;
      }
   }
   return 0;
}

//
// smallint
//    converts a bigint to an int.  returns an int
//
int bigint::smallint () const {
   assert (((*this).compare (INT_MIN) == -1)
           || ((*this).compare (INT_MAX) == 1));
   if (((*this).compare (INT_MIN) == 1)
       || ((*this).compare (INT_MAX) == -1))
      throw range_error ("smallint: out of range");
   
   int result = 0;
   int curr, multiplier;
   unsigned char currc;
   vector<bigint::digit_t>::const_iterator itor;
   itor = this->big_value->end ();
   for (int i = this->big_value->size () - 1; i >= 0; --i) {
      currc = *itor;
      curr = currc -'0';
      if (curr != 0) {
         multiplier = 1;
         for (int j = 1; j <= i; ++j) {
            multiplier *= 10;
         }
         curr *= multiplier;
      }
      result += curr;
      --itor;
   }
   if (this->negative == true) {
      result = (-1)*(result);
   }
   return result;
}

//
// mul_by_2
//    returns a bigint of this times two.  calls on do_bigadd() to
//    double the size of this and keeps the sign unaltered
//
bigint bigint::mul_by_2 () {
   bigint double_this = (*this);
   double_this = double_this.do_bigadd (*this);
   return double_this;
}

//
// do_bigadd
//    returns a bigint sum of this and that
//
bigint bigint::do_bigadd (const bigint &that) const {
   int maxsize_x = this->big_value->size ();
   int maxsize_y = that.big_value->size ();
   int maxsize;
   if (maxsize_x < maxsize_y) { maxsize = maxsize_y; }
   else { maxsize = maxsize_x; }
   int x, y, sum;
   int carry = 0;
   unsigned char currc;
   bigint bigsum;
   if (this->abscompare (that) == 1) {
      bigsum.negative = this->negative;
   }else if (this->abscompare (that) == -1) {
      bigsum.negative = that.negative;
   }else {
      if (this->negative == that.negative) {
         bigsum.negative = this->negative;
      }else {
         bigsum.negative = false;
      }
   }
   vector<bigint::digit_t>::const_iterator thisitor, thatitor;
   
   thisitor = this->big_value->begin ();
   thatitor = that.big_value->begin ();
   for (int i = 0; i < maxsize; ++i) {
      if (i < maxsize_x) {
         currc = *thisitor;
         x = currc - '0';
         ++thisitor;
      }else { x = 0; }
      if (i < maxsize_y) {
         currc = *thatitor;
         y = currc - '0';
         ++thatitor;
      }else { y = 0; }
      sum = x + y + carry;
      if (sum > 9) {
         carry = 1;
         sum -= 10;
         currc = sum + '0';
      }
      else {
         carry = 0;
         currc = sum + '0';
      }
      bigsum.big_value->push_back (currc);
   }
   
   if (carry == 1) {
      currc = carry + '0';
      bigsum.big_value->push_back (currc);
   }
   return bigsum;
}

//
// do_bigsub
//    returns a bigint difference of that from this
//
bigint bigint::do_bigsub (const bigint &that) const {
   int maxsize_x = this->big_value->size ();
   int maxsize_y = that.big_value->size ();
   int maxsize;
   if (maxsize_x < maxsize_y) { maxsize = maxsize_y; }
   else { maxsize = maxsize_x; }
   int x, y, diff;
   int borrow = 0;
   unsigned char currc;
   bigint bigdiff;
   if (this->abscompare (that) == 1) {
      bigdiff.negative = this->negative;
   }else if (this->abscompare (that) == -1) {
      bigdiff.negative = that.negative;
   }else {
      if (this->negative == that.negative) {
         bigdiff.negative = false;
      }else {
         bigdiff.negative = true;
      }
   }

   vector<bigint::digit_t>::const_iterator thisitor, thatitor;
   
   thisitor = this->big_value->begin ();
   thatitor = that.big_value->begin ();
   for (int i = 0; i < maxsize; ++i) {
      if (i < maxsize_x) {
         currc = *thisitor;
         x = currc - '0';
         ++thisitor;
      }else { x = 0; }
      if (i < maxsize_y) {
         currc = *thatitor;
         y = currc - '0';
         ++thatitor;
      }else { y = 0; }
      x += borrow;
      if (x < y) { x += 10; borrow = -1; }
      else { borrow = 0; }
      diff = x - y;
      currc = diff + '0';
      bigdiff.big_value->push_back (currc);

   }
   
   while (bigdiff.big_value->back () == '0') {
      bigdiff.big_value->pop_back ();
   }
   return bigdiff;
}

//
// popstack
//    static function that pops and returns the top of a bigpair stack.
//    called by operator*()
//
static bigpair popstack (stack <bigpair> &egyptstack) {
   bigpair result = egyptstack.top ();
   egyptstack.pop();
   return result;
}

//
// operator*
//    Ancient Egyptian multiplication algorithm.
//    returns the bigint result of this times that
//
bigint bigint::operator* (const bigint &that) const {
   bigint big, small;
   if (that.abscompare (*this) > -1) {
      big = that;
      small = *this;
   }else {
      big = *this;
      small = that;
   }
   bigint count = (1);
   TRACE ('*', *this << " * " << that);
   stack <bigpair> egyptstack;
   
   while (count.abscompare (small) <= 0) {
      egyptstack.push (bigpair (count, big));
      count = count.mul_by_2 ();
      big = big.mul_by_2 ();
   }
   
   bigint result = 0;
   bigpair top;
   while (!egyptstack.empty ()) {
      top = popstack (egyptstack);
      count = top.first;
      big = top.second;
      if (count.abscompare (small) <= 0) {
         small = (small) - (count);
         result = (result) + (big);
      }
   }

   if (this->negative != that.negative) result = -(result);
   return result;
}

//
// div_rem
//    Ancient Egyptian division algorithm.
//    returns the bigint quotient and remainder of this divided by that
//
bigpair bigint::div_rem (const bigint &that) const {
   if (that == 0) throw range_error ("divide by 0");
   bigint numer = *this;
   bigint denom = that;
   bigint count = (1);
   TRACE ('/', *this << " /% " << that);
   stack <bigpair> egyptstack;
   
   while (denom.abscompare (numer) <= 0) {
      egyptstack.push (bigpair (count, denom));
      count = count.mul_by_2 ();
      denom = denom.mul_by_2 ();
   }
   
   bigint quotient = 0;
   bigint remainder = numer;
   while (!egyptstack.empty ()) {
      bigpair top = popstack (egyptstack);
      count = top.first;
      denom = top.second;
      if (denom.abscompare (remainder) <= 0) {
         remainder = remainder - denom;
         quotient = (quotient) + count;
      }
   }
   
   return bigpair (quotient, remainder);
}

//
// operator/
//    returns the quotient from a division.  calls on div_rem()
//
bigint bigint::operator/ (const bigint &that) const {
   return div_rem (that).first;
}

//
// operator%
//    returns the remainder (modulous) from a division.  calls on
//    div_rem()
//
bigint bigint::operator% (const bigint &that) const {
   return div_rem (that).second;
}

#define TRACE_POW \
   TRACE ('^', "result: " << result << ", base: " << base \
            << ", expt: " << expt);
bigint bigint::pow (const bigint &that) const {
   bigint base = *this;
   if (that.compare (999) == -1) throw range_error ("exp too big");
   int expt = that.smallint();
   bigint result = 1;
   TRACE_POW;
   if (expt < 0) {
      base = 1 / base;
      expt = - expt;
   }
   while (expt > 0) {
      TRACE_POW;
      if (expt & 1) { //odd
         result = result * base;
         --expt;
      }else { //even
         base = base * base;
         expt /= 2;
      }
   }
   TRACE_POW;
   return result;
}

//
// Macros can make repetitive code easier.
//

#define COMPARE(OPER) \
   bool bigint::operator OPER (const bigint &that) const { \
      return compare (that) OPER 0; \
   }
COMPARE (==)
COMPARE (!=)
COMPARE (< )
COMPARE (<=)
COMPARE (> )
COMPARE (>=)

#define INT_LEFT(RESULT,OPER) \
   RESULT operator OPER (int left, const bigint &that) { \
      return bigint (left) OPER that; \
   }
INT_LEFT (bigint, +)
INT_LEFT (bigint, -)
INT_LEFT (bigint, *)
INT_LEFT (bigint, /)
INT_LEFT (bigint, %)
INT_LEFT (bool, ==)
INT_LEFT (bool, !=)
INT_LEFT (bool, < )
INT_LEFT (bool, <=)
INT_LEFT (bool, > )
INT_LEFT (bool, >=)

ostream &operator<< (ostream &out, const bigint &that) {
   if (that.negative == true) {
      out << "-";
   }
   int count = 0;
   unsigned char currc;
   vector<bigint::digit_t>::const_iterator itor = that.big_value->end();
   for (int i = that.big_value->size () - 1; i >= 0; --i) {
      ++count;
      if (count == 70) {
         out << "\\" << endl;
         count = 1;
      }
      currc = *itor;
      out << currc;
      --itor;
   }
   return out;
}

@


1.9
log
@-
@
text
@d1 1
a1 1
/* $Id: bigint.cpp,v 1.8 2011-02-01 11:41:16-08 dmfrank - $
d193 1
a193 1
   }else if (this->negative == that.negative == true) {
@


1.8
log
@-
@
text
@d1 1
a1 1
/* $Id: bigint.cpp,v 1.201 2011-02-01 11:39:22-08 dmfrank - $
d14 1
@


1.7
log
@-
@
text
@d1 1
a1 1
/* $Id: bigint.cpp,v 1.197 2011-02-01 11:25:13-08 dmfrank - $
d471 1
d473 1
a473 1
      bigpair top = popstack (egyptstack);
d482 1
a482 2
   if ((this->negative == true) != (that.negative == true))
      result = -(result);
d606 1
a606 1
         count = 0;
@


1.6
log
@-
@
text
@d1 1
a1 1
/* $Id: bigint.cpp,v 1.189 2011-02-01 10:33:52-08 dmfrank - $
d125 1
a125 1
   bigint bigsum = 0;
d152 1
a152 1
   bigint bigdiff = 0;
d154 1
a154 1
   
d162 1
d333 1
a333 1
   if (this->abscompare (that) > -1) {
d335 2
d338 5
a342 1
      bigsum.negative = that.negative;
d384 1
a384 1
   int maxsize = this->big_value->size ();
d386 3
d393 12
a404 1
   bigdiff.negative = this->negative;
d410 5
a414 3
      currc = *thisitor;
      x = currc - '0';
      x += borrow;
d420 1
d426 1
a426 1
      ++thisitor;
@


1.5
log
@-
@
text
@d1 1
a1 1
/* $Id: bigint.cpp,v 1.162 2011-02-01 08:58:37-08 dmfrank - $
d183 1
a183 1
//    the most significant.  returns 1 if this is smaller than that, -1
d188 2
d191 1
a191 3
   }else if (this->negative == false && that.negative == true) {
      return -1;
   }else if (this->negative == that.negative) {
d193 2
a195 2
      }else if (this->big_value->size () > that.big_value->size ()) {
         return 1;
d205 2
a207 2
            }else if (thisc > thatc) {
               return 1;
d215 2
a217 2
      }else if (this->big_value->size () > that.big_value->size ()) {
         return -1;
d227 2
a229 2
            }else if (thisc > thatc) {
               return -1;
d277 4
a280 4
   assert (*this < numeric_limits<int>::min()
           || *this > numeric_limits<int>::max());
   if (*this < numeric_limits<int>::min()
       || *this > numeric_limits<int>::max())
d440 1
a440 1
   while (count <= small) {
d448 4
a451 2
      bigpair (count, big) = popstack (egyptstack);
      if (count <= small) {
d475 1
a475 1
   while (denom <= numer) {
d484 4
a487 2
      bigpair (count, denom) = popstack (egyptstack);
      if (denom <= remainder) {
d518 1
a518 1
   if (999 < that) throw range_error ("exp too big");
@


1.4
log
@-
@
text
@d1 1
a1 1
/* $Id: bigint.cpp,v 1.105 2011-01-31 23:06:13-08 dmfrank - $
d22 4
d35 1
a47 1
   
d69 2
a70 1
                     
d72 2
a73 1
      this->big_value->push_back ('0');
d85 2
a86 1
         this->big_value->push_back ((char) curr);
d101 2
a102 2
   string::const_iterator itor = that.end();
   string::const_iterator begin = that.begin();
d107 1
a107 1
   char temp;
d109 2
a110 2
      temp = *itor;
      this->big_value->push_back (temp);
d112 2
d126 2
d153 2
d183 1
a183 1
//    the most significant.  returns -1 if this is smaller than that, 1
d188 2
a190 2
   }else if (this->negative == false && that.negative == true) {
      return 1;
d193 2
a195 2
      }else if (this->big_value->size () > that.big_value->size ()) {
         return -1;
d197 4
d202 5
a206 1
            if (this->big_value->at(i) < that.big_value->at(i)) {
a207 2
            }else if (this->big_value->at(i) > that.big_value->at(i)) {
               return -1;
d209 2
d215 2
a217 2
      }else if (this->big_value->size () > that.big_value->size ()) {
         return 1;
d219 4
d224 5
a228 1
            if (this->big_value->at(i) < that.big_value->at(i)) {
a229 2
            }else if (this->big_value->at(i) > that.big_value->at(i)) {
               return 1;
d231 2
d253 4
d258 3
a260 1
         if (this->big_value->at(i) < that.big_value->at(i)) {
d262 1
a262 1
         }else if (this->big_value->at(i) > that.big_value->at(i)) {
d265 2
d285 3
d289 2
a290 1
      curr = this->big_value->at (i) -'0';
d299 1
d302 1
a302 1
      result = -1*result;
d330 11
a340 2
   bigint bigsum = 0;
   bigsum.negative = this->negative;
d342 10
a351 4
      if (i < maxsize_x) { x = this->big_value->at(i) - '0'; }
      else { x = 0; }
      if (i < maxsize_y) { y = that.big_value->at(i) - '0'; }
      else { y = 0; }
d353 15
a367 3
      if (sum > 9) { carry = 1; sum -= 10; }
      else { carry = 0; }
      bigsum.big_value->push_back ((char) sum);
a368 1
   if (carry == 1) bigsum.big_value->push_back ((char) carry);
d381 2
a382 1
   bigint bigdiff = 0;
d384 4
d389 2
a390 1
      x = this->big_value->at(i) - '0';
d392 5
a396 2
      if (i < maxsize_y) { y = that.big_value->at(i) - '0'; }
      else { y = 0; }
d400 3
a402 1
      bigdiff.big_value->push_back ((char) diff);
d404 1
a408 1
   
d425 1
a425 1
//    
d428 2
a429 3
   bigint big = 0;
   bigint small = 0;
   if (that.abscompare (*this) == 1) {
d441 1
a441 1
      egyptstack.push (pair<bigint, bigint> (count, big));
d448 1
a448 1
      pair<bigint, bigint> (count, big) = popstack (egyptstack);
d450 2
a451 2
         small = small - (count);
         result = result + (big);
d454 1
a454 4
   
   delete &big;
   delete &small;
   delete &count;
d463 1
a463 1
//
d474 1
a474 1
      egyptstack.push (pair<bigint, bigint> (count, denom));
d479 1
a479 1
   bigint quotient = (0);
d482 1
a482 1
      pair<bigint, bigint> (count, denom) = popstack (egyptstack);
d485 1
a485 1
         quotient = quotient + count;
a488 3
   delete &numer;
   delete &denom;
   delete &count;
d494 1
a494 1
//    
d500 1
d502 3
a504 1
//    
d514 1
a514 1
   if (that > 999) throw range_error ("exp too big");
d572 2
d580 3
a582 1
      out << that.big_value->at (i);
@


1.3
log
@-
@
text
@d1 1
a1 1
/* $Id: bigint.cpp,v 1.46 2011-01-31 06:19:02-08 dmfrank - $
d116 1
a116 1
   bigint *bigsum = new bigint ();
d118 1
a118 1
      *bigsum = (*this).do_bigadd (that);
d121 1
a121 1
         *bigsum = (*this).do_bigsub (that);
d123 1
a123 1
         *bigsum = that.do_bigsub (*this);
d125 1
a125 1
         bigsum->big_value->push_back ('0');
d128 1
a128 1
   return *bigsum;
d141 1
a141 1
   bigint *bigdiff = new bigint ();
d143 1
a143 1
      *bigdiff = (*this).do_bigadd (that);
d146 1
a146 1
         *bigdiff = (*this).do_bigsub (that);
d148 1
a148 1
         *bigdiff = that.do_bigsub (*this);
d150 1
a150 1
         bigdiff->big_value->push_back ('0');
d153 1
a153 1
   return *bigdiff;
d161 3
a163 1
   return (*this).change_sign ();
d236 2
a237 3
// change_sign
//    equivalent to multiplying this by -1.  simply makes the sign
//    opposite what it was
d239 24
a262 3
bigint &bigint::change_sign () const {
   this->negative = !this->negative;
   return *this;
d265 5
d271 3
a273 1
   return this->small_value *= 2;
d288 2
a289 2
   bigint *bigsum = new bigint ();
   bigsum->negative = this->negative;
d298 1
a298 1
      bigsum->big_value->push_back ((char) sum);
d300 2
a301 2
   if (carry == 1) bigsum->big_value->push_back ((char) carry);
   return *bigsum;
d313 2
a314 2
   bigint *bigdiff = new bigint ();
   bigdiff->negative = this->negative;
d323 1
a323 1
      bigdiff->big_value->push_back ((char) diff);
d325 2
a326 2
   while (bigdiff->big_value->back () == '0') {
      bigdiff->big_value->pop_back ();
d328 1
a328 1
   return *bigdiff;
d332 5
d344 3
a346 1
// Ancient Egyptian multiplication algorithm.
d349 10
a358 2
   bigint top = that;
   bigint count = 1;
d361 7
a367 1
   popstack (egyptstack); // junk to suppress a warning
d369 13
a381 1
   if ((*this < 0) != (that < 0)) result = - result;
d386 3
a388 1
// Ancient Egyptian division algorithm.
d392 3
a394 2
   bigint count = 1;
   bigint top = abs (that.small_value);
d397 20
a416 2
   bigint quotient = 0;
   bigint remainder = abs (this->small_value);
d420 4
d428 2
d493 3
a504 1
   out << endl;
@


1.2
log
@-
@
text
@d1 1
a1 1
/* $Id: bigint.cpp,v 1.3 2011-01-19 18:42:21-08 dmfrank - $
d22 1
a22 1
bigint::bigint (): small_value (0) {
d25 7
a31 2
bigint::bigint (const bigint &that): small_value (that.small_value) {
   *this = that;
d34 6
d42 5
a46 1
   this->small_value = that.small_value;
d50 4
d56 1
d59 23
a81 1
bigint::bigint (int that): small_value (that) {
d84 8
a91 1
bigint::bigint (const string &that) {
d93 12
a104 7
   string::const_iterator itor = that.begin();
   string::const_iterator end = that.end();
   bool isnegative = false;
   if (*itor == '_') {isnegative = true; ++itor; }
   int newval = 0;
   for (; itor != end; ++itor) newval = newval * 10 + *itor - '0';
   small_value = isnegative ? - newval : + newval;
d107 8
d116 13
a128 1
   return this->small_value + that.small_value;
d131 9
d141 13
a153 1
   return this->small_value - that.small_value;
d156 4
d161 1
a161 1
   return -small_value;
d164 7
d172 34
a205 2
   return this->small_value < that.small_value ? -1
        : this->small_value > that.small_value ? +1 : 0;
d208 8
d217 14
a230 2
   return abs (this->small_value) < abs (that.small_value) ? -1
        : abs (this->small_value) > abs (that.small_value) ? +1 : 0;
d233 8
a240 5
int bigint::smallint () const {
   if (*this < numeric_limits<int>::min()
    || *this > numeric_limits<int>::max())
               throw range_error ("smallint: out of range");
   return small_value;
d247 56
d404 10
a413 1
   out << that.small_value;
@


1.1
log
@-
@
text
@d1 9
a9 1
// $Id: bigint.cc,v 1.2 2011-01-18 22:18:35-08 - - $
@
