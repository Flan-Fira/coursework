head	1.8;
access;
symbols;
locks;
comment	@// @;


1.8
date	2011.01.28.04.24.24;	author dmfrank;	state -;
branches;
next	1.7;

1.7
date	2011.01.19.18.45.44;	author dmfrank;	state -;
branches;
next	1.6;

1.6
date	2011.01.19.18.45.00;	author dmfrank;	state -;
branches;
next	1.5;

1.5
date	2011.01.19.18.37.52;	author dmfrank;	state -;
branches;
next	1.4;

1.4
date	2011.01.19.17.26.15;	author dmfrank;	state -;
branches;
next	1.3;

1.3
date	2011.01.19.12.20.43;	author dmfrank;	state -;
branches;
next	1.2;

1.2
date	2011.01.18.14.40.34;	author dmfrank;	state -;
branches;
next	1.1;

1.1
date	2011.01.18.13.41.45;	author dmfrank;	state -;
branches;
next	;


desc
@@


1.8
log
@-
@
text
@/* $Id: commands.cpp,v 1.121 2011-01-19 11:20:34-08 dmfrank - $
 * Derek Frank, dmfrank@@ucsc.edu
 *
 * NAME
 *   commands
 *
 * DESCRIPTION
 *   
 */

#include "commands.h"
#include "trace.h"

commands::commands(): map (commandmap()) {
   map["cat"    ] = fn_cat    ;
   map["cd"     ] = fn_cd     ;
   map["echo"   ] = fn_echo   ;
   map["exit"   ] = fn_exit   ;
   map["ls"     ] = fn_ls     ;
   map["lsr"    ] = fn_lsr    ;
   map["make"   ] = fn_make   ;
   map["mkdir"  ] = fn_mkdir  ;
   map["prompt" ] = fn_prompt ;
   map["pwd"    ] = fn_pwd    ;
   map["rm"     ] = fn_rm     ;
}

function commands::operator[] (const string& cmd) {
   return map[cmd];
}

void fn_cat (inode_state &state, const wordvec &words) {
   TRACE ('c', state);
   TRACE ('c', words);
}

void fn_cd (inode_state &state, const wordvec &words) {
   TRACE ('c', state);
   TRACE ('c', words);
}

void fn_echo (inode_state &state, const wordvec &words) {
   TRACE ('c', state);
   TRACE ('c', words);
   if (words.size() > 1) {
      for (unsigned int i = 1; i < words.size(); ++i) {
         cout << words[i] << " ";
      }
   }
   cout << endl;
}

void fn_exit (inode_state &state, const wordvec &words) {
   TRACE ('c', state);
   TRACE ('c', words);
   
   if (words.size() > 2) {
      // set exit status to 255 if more than one argument is present
      exit_status::set(255);
   }else if (words.size() == 1){
      // no status given, set to 0
      // exit_status::set(0);
   }else {
      // set exit status to 255 if status is non-numeric
      // or convert status to int and set as exit status
      for (unsigned int i = 0; i < words[1].length(); ++i) {
         if (!std::isdigit(words[1][i])) {
            // status can be negative
            if (i == 0 && words[1][0] == '-') {
            }else {
               exit_status::set(255);
               throw ysh_exit_exn ();
            }
         }
      }
      // convert status from string to int then set as status
      int status = str2int(words[1]);
      exit_status::set(status);
   }
   // throw exception of given status
   throw ysh_exit_exn ();
}

void fn_ls (inode_state &state, const wordvec &words) {
   TRACE ('c', state);
   TRACE ('c', words);
   
   inode current = *(state.get_cwd());
   if (current.get_type() == DIR_INODE) {
      cout << state.get_cwd_names() << ":" << endl;
      current.print_map(current.get_dirents());
   }else if (current.get_type() == FILE_INODE) {
      
   }
}

void fn_lsr (inode_state &state, const wordvec &words) {
   TRACE ('c', state);
   TRACE ('c', words);
}

void fn_make (inode_state &state, const wordvec &words) {
   TRACE ('c', state);
   TRACE ('c', words);
}

void fn_mkdir (inode_state &state, const wordvec &words) {
   TRACE ('c', state);
   TRACE ('c', words);
   
   inode newdir (DIR_INODE);
   
   if (words.size() < 2) {
      throw yshell_exn (words[0] + ": no pathname specified");
   }
   if (words[1][0] == '/') {
      // pathname begins at root
      string root = (*(state.get_root())).get_dirname();
      
   }else if (words[1][0] == '.' && words[1][1] != '.') {
      // pathname begins with current directory
      
   }else if (words[1][0] == '.' && words[1][1] == '.') {
      //pathname begins with parent directory
      
   }else {
      size_t found;
      string path;
      inode current = *(state.get_cwd());
      unsigned int count = 1;
      // check if the pathname already exists, if so, print to cerr.
      // otherwise create directory in specified pathname
      if (words[1].length() > 0) {
         found= words[1].find_first_of ("/");
         path = words[1].substr(0,found);
      }
      while (count <= words[1].length()) {
         directory *entries = current.get_dirents();
         directory::const_iterator itor = entries->begin();
         for (; itor != entries->end(); ++itor) {
            if (path.compare (itor->first) == 0) {
               if (found == words[1].length()) {
                  throw yshell_exn (words[0]
                                    + ": directory already exists");
               }else {
                  current = *(itor->second);
                  break;
               }
            }
         }
         // search for next "/" in pathname
         size_t temp = found;
         found =  words[1].find_first_of ("/", found+1);
         path = words[1].substr(temp+1,found);
         ++count;
      }
   }
   
   // newdir.alter_dirname (words[1]);
   newdir.insert_dirents (".", &newdir);
   newdir.insert_dirents ("..", &newdir);
}

void fn_prompt (inode_state &state, const wordvec &words){ 
   TRACE ('c', state);
   TRACE ('c', words);
   
   string newprompt = "";
   if ( words.size() > 1 ) {
      for (unsigned int i = 1; i < words.size(); ++i) {
         if (i != words.size()-1) {
            newprompt.append (words[i]+" ");
         }else {
            newprompt.append (words[i]);
         }
      }
   }
   state.alter_prompt (newprompt);
}

void fn_pwd (inode_state &state, const wordvec &words) {
   TRACE ('c', state);
   TRACE ('c', words);
   
   cout << state.get_cwd_names() << endl;
}

void fn_rm (inode_state &state, const wordvec &words) {
   TRACE ('c', state);
   TRACE ('c', words);
}

void fn_rmr (inode_state &state, const wordvec &words) {
   TRACE ('c', state);
   TRACE ('c', words);
}

int exit_status_message() {
   int exit_status = exit_status::get();
   cout << execname() << ": exit(" << exit_status << ")" << endl;
   return exit_status;
}
@


1.7
log
@-
@
text
@d1 1
a1 1
/* $Id: commands.cpp,v 1.114 2011-01-19 10:41:37-08 dmfrank - $
d127 4
d133 5
a137 4
      inode current = *(state.get_cwd());
      /*while (words[1].length() > 0) {
         size_t found = words[1].find_first_of("/");
         string path = words[1].substr(0,found);
d151 6
a156 3
         // erase substring up to first "/" or endl
         words[1].erase (found);
      }*/
@


1.6
log
@-
@
text
@d147 2
a148 2
         words[1].erase (found);*/
      }
@


1.5
log
@-
@
text
@d1 1
a1 1
/* $Id: commands.cpp,v 1.113 2011-01-19 10:34:23-08 dmfrank - $
d130 2
a131 2
      while (words[1].length() > 0) {
         unsigned int found = words[1].find_first_of("/");
d147 1
a147 1
         //words[1].erase (0, words[1].begin() + found);
@


1.4
log
@-
@
text
@d1 1
a1 1
/* $Id: commands.cpp,v 1.98 2011-01-19 09:14:10-08 dmfrank - $
d127 1
a127 2
      // if the directory already exists, then check if it is already a
      // pathname, if so, print to cerr
d129 20
a148 1
      
@


1.3
log
@-
@
text
@d1 1
a1 1
/* $Id: commands.cpp,v 1.72 2011-01-19 04:14:11-08 dmfrank - $
a12 1
//#include "util.h"
d62 1
a62 1
      exit_status::set(0);
d87 8
d110 26
d145 5
a149 1
         newprompt.append(words[i]+" ");
a176 1

@


1.2
log
@-
@
text
@d1 1
a1 1
/* $Id: commands.cpp,v 1.5 2011-01-17 09:20:37-08 dmfrank - $
d13 1
d33 1
a33 1
void fn_cat (inode_state &state, const wordvec &words){
d38 1
a38 1
void fn_cd (inode_state &state, const wordvec &words){
d43 1
a43 1
void fn_echo (inode_state &state, const wordvec &words){
d46 6
d54 1
a54 1
void fn_exit (inode_state &state, const wordvec &words){
d57 25
d85 1
a85 1
void fn_ls (inode_state &state, const wordvec &words){
d90 1
a90 1
void fn_lsr (inode_state &state, const wordvec &words){
d95 1
a95 1
void fn_make (inode_state &state, const wordvec &words){
d100 1
a100 1
void fn_mkdir (inode_state &state, const wordvec &words){
d105 1
a105 1
void fn_prompt (inode_state &state, const wordvec &words){
d108 8
d118 1
a118 1
void fn_pwd (inode_state &state, const wordvec &words){
d121 2
d125 1
a125 1
void fn_rm (inode_state &state, const wordvec &words){
d130 1
a130 1
void fn_rmr (inode_state &state, const wordvec &words){
@


1.1
log
@-
@
text
@d5 1
a5 1
 *   commands â€” 
@
