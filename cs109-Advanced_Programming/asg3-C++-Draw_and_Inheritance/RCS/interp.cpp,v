head	1.29;
access;
symbols;
locks;
comment	@// @;


1.29
date	2011.02.15.07.34.10;	author dmfrank;	state -;
branches;
next	1.28;

1.28
date	2011.02.15.07.31.38;	author dmfrank;	state -;
branches;
next	1.27;

1.27
date	2011.02.15.07.24.01;	author dmfrank;	state -;
branches;
next	1.26;

1.26
date	2011.02.15.07.22.53;	author dmfrank;	state -;
branches;
next	1.25;

1.25
date	2011.02.15.07.12.09;	author dmfrank;	state -;
branches;
next	1.24;

1.24
date	2011.02.15.07.04.55;	author dmfrank;	state -;
branches;
next	1.23;

1.23
date	2011.02.15.07.01.23;	author dmfrank;	state -;
branches;
next	1.22;

1.22
date	2011.02.15.07.00.03;	author dmfrank;	state -;
branches;
next	1.21;

1.21
date	2011.02.15.06.35.09;	author dmfrank;	state -;
branches;
next	1.20;

1.20
date	2011.02.15.06.31.15;	author dmfrank;	state -;
branches;
next	1.19;

1.19
date	2011.02.15.06.03.58;	author dmfrank;	state -;
branches;
next	1.18;

1.18
date	2011.02.15.05.29.29;	author dmfrank;	state -;
branches;
next	1.17;

1.17
date	2011.02.15.04.50.34;	author dmfrank;	state -;
branches;
next	1.16;

1.16
date	2011.02.14.21.59.27;	author dmfrank;	state -;
branches;
next	1.15;

1.15
date	2011.02.14.20.11.22;	author dmfrank;	state -;
branches;
next	1.14;

1.14
date	2011.02.14.20.00.25;	author dmfrank;	state -;
branches;
next	1.13;

1.13
date	2011.02.14.19.57.57;	author dmfrank;	state -;
branches;
next	1.12;

1.12
date	2011.02.14.19.43.07;	author dmfrank;	state -;
branches;
next	1.11;

1.11
date	2011.02.14.19.41.00;	author dmfrank;	state -;
branches;
next	1.10;

1.10
date	2011.02.14.19.30.39;	author dmfrank;	state -;
branches;
next	1.9;

1.9
date	2011.02.14.19.24.59;	author dmfrank;	state -;
branches;
next	1.8;

1.8
date	2011.02.14.19.18.02;	author dmfrank;	state -;
branches;
next	1.7;

1.7
date	2011.02.14.19.13.51;	author dmfrank;	state -;
branches;
next	1.6;

1.6
date	2011.02.14.18.49.39;	author dmfrank;	state -;
branches;
next	1.5;

1.5
date	2011.02.14.13.23.23;	author dmfrank;	state -;
branches;
next	1.4;

1.4
date	2011.02.14.13.13.02;	author dmfrank;	state -;
branches;
next	1.3;

1.3
date	2011.02.14.08.25.24;	author dmfrank;	state -;
branches;
next	1.2;

1.2
date	2011.02.02.16.39.52;	author dmfrank;	state -;
branches;
next	1.1;

1.1
date	2011.02.02.16.09.48;	author dmfrank;	state -;
branches;
next	;


desc
@@


1.29
log
@-
@
text
@/* $Id: interp.cpp,v 1.52 2011-02-14 22:45:19-08 dmfrank - $
 * Derek Frank, dmfrank@@ucsc.edu
 *
 * NAME
 *    interp
 *
 * DESCRIPTION
 *    Implementation for interp class.
*/

#include <list>
#include <map>
#include <string>

using namespace std;

#include "interp.h"
#include "object.h"
#include "util.h"

//
// ctor
//    Constructor for the interpreter class.
//
interpreter::interpreter(const string &filename, ostream &outfile,
                         objectmap &objmap):
   outfile(outfile), pagenr(1), objmap(objmap), infilename(filename),
   page_xoffset (inches (.25)), page_yoffset (inches (.25)) {
   if (interpmap.size() == 0) {
      interpmap["define" ] = &interpreter::do_define ;
      interpmap["draw"   ] = &interpreter::do_draw   ;
      interpmap["newpage"] = &interpreter::do_newpage;
   }
   if (factorymap.size() == 0) {
      factorymap["text"     ] = &interpreter::make_text     ;
      factorymap["ellipse"  ] = &interpreter::make_ellipse  ;
      factorymap["circle"   ] = &interpreter::make_circle   ;
      factorymap["polygon"  ] = &interpreter::make_polygon  ;
      factorymap["rectangle"] = &interpreter::make_rectangle;
      factorymap["square"   ] = &interpreter::make_square   ;
      factorymap["line"     ] = &interpreter::make_line     ;
   }
   prolog ();
   startpage ();
}

//
// dtor
//    Destructor for the interpreter class.
//
interpreter::~interpreter () {
   endpage ();
   epilog ();

   objectmap::iterator itor = objmap.begin ();
   for (; itor != objmap.end (); ++itor) {
      delete itor->second;
   }
}

//
// interpmap
//    Map that selects functions to carry out the various commands.
//
map <string, interpreter::interpreterfn> interpreter::interpmap;

//
// factorymap
//    Map that contains pointers to the carious factory functions.
//
map <string, interpreter::factoryfn> interpreter::factorymap;

//
// shift
//    Function that pops the front of a list of strings.  Returns the
//    front of the list as a string.
//
string shift (list<string> &words) {
   if (words.size() == 0) throw runtime_error ("syntax error");
   string front = words.front();
   words.pop_front();
   return front;
}

//
// interpret
//    Looks up a function based on a command and call
//
void interpreter::interpret (parameters &params) {
   TRACE ('i', params);
   string command = shift (params);
   interpreterfn function = interpmap[command];
   if (function == NULL) throw runtime_error ("syntax error");
   (this->*function) (params);
}

//
// do_define
//    Takes care of accessing the factory to make new objects.
//
void interpreter::do_define (parameters &params) {
   TRACE ('i', params);
   string name = shift (params);
   objmap[name] = make_object (params);
}

//
// do_draw
//    Takes care of accessing the factory and telling objects when to
//    draw themselves.
//
void interpreter::do_draw (parameters &params) {
   TRACE ('i', params);
   string name = shift (params);
   object *thing = objmap[name];
   if (thing == NULL) throw runtime_error (name + ": no such object");
   degrees angle = degrees (0);

   // If there exists three parameters, try to convert the last to a
   // double and store it as the angle.  Catch and throw any syntax
   // errors.
   if (params.size() == 3) {
      try {
         angle = degrees (from_string<double> (params.back()));
         params.pop_back();
      } catch (domain_error error) {
         throw runtime_error ("syntax error");
      }
   }

   // Unable to use try-catch statement to catch any syntax errors.
   if (params.size() != 2) { throw runtime_error ("syntax error"); }
   xycoords coords (inches (from_string<double> (params.front () )),
                    inches (from_string<double> (params.back () )));
   
   thing->draw (outfile, coords, angle);
}

//
// do_newpage
//    Ends and starts a new page for drawing.  Throws a syntax error if
//    the command list is not empty.
//
void interpreter::do_newpage (parameters &params) {
   if (params.size() != 0) throw runtime_error ("syntax error");
   endpage ();
   ++pagenr;
   startpage ();
}

//
// prolog
//    Writes the prolog comments for a new Postscript program.
//
void interpreter::prolog () {
   outfile << "%!PS-Adobe-3.0" << endl;
   outfile << "%%Creator: " << sys_info::get_execname () << endl;
   outfile << "%%CreationDate: " << datestring() << endl;
   outfile << "%%PageOrder: Ascend" << endl;
   outfile << "%%Orientation: Portrait" << endl;
   outfile << "%%SourceFile: " << infilename << endl;
   outfile << "%%EndComments" << endl;
}

//
// startpage
//    Starts a new Postscript page.
//
void interpreter::startpage () {
   outfile << endl
           << "%%Page: " << pagenr << " " << pagenr << endl
           << page_xoffset << " " << page_yoffset
                           << " translate" << endl
           << "/Courier findfont 10 scalefont setfont" << endl
           << "0 0 " << "moveto" << endl
           << "(" << infilename << ":" << pagenr << ") show" << endl;
}

//
// endpage
//    Ends a Postscript page.
//
void interpreter::endpage () {
   outfile << endl;
   outfile << "showpage" << endl;
   outfile << "grestoreall" << endl;
}

//
// epilog
//    Writes the epilog to a Postscript program.
//
void interpreter::epilog () {
   outfile << endl;
   outfile << "%%Trailer" << endl;
   outfile << "%%Pages: " << pagenr << endl;
   outfile << "%%EOF" << endl;

}

//
// make_object
//    Determines what kind of object needs to be created, then calles an
//    appropriate factory function.
//
object *interpreter::make_object (parameters &command) {
   TRACE ('f', command);
   string type = shift (command);
   factoryfn func = factorymap[type];
   if (func == NULL) throw runtime_error (type + ": no such object");
   return (this->*func) (command);
}

//
// make_text
//    Create and return a pointer to a text object initialized to the
//    given list of parameters.  Scan the parameter list for validity
//    and throw a syntax error if the number of parameters is incorrect,
//    or if a non-number is given for any argument other than the font
//    name and words of a text.
//
object *interpreter::make_text (parameters &command) {
   TRACE ('f', command);
   if (command.size () < 2)
      throw runtime_error ("syntax error");

   // Pop the next string argument from the command list.  Try to
   // convert it to a double and set it as the font size.  If it
   // contains non-numbers, from_string() will throw an error.  Catch
   // the error and set the string as the font style.  Set the font size
   // to the default of 12.0 points.
   double size;
   string temp;
   try {
      temp = shift (command);
      size = from_string<double> (temp);
      temp = shift (command);
   } catch (domain_error error) {
      size = 12.0;
   }
    string font = temp;
   
   // Throw a syntax error if the font style contains any numbers.
   string::iterator itor = font.begin ();
   for (; itor != font.end (); ++itor) {
      unsigned char ctemp = *itor;
      int dtemp = ctemp -'0';
      if (0 <= dtemp && dtemp <= 9)
         throw runtime_error ("syntax error"); 
   }
 
   // Loop through the rest of the command list.  Pop and append each
   // string to the text string.
   string txt = shift (command);
   while (!command.empty ()) {
      string temp = shift (command);
      txt.append (" " + temp);
   }
   
   // Iterate throw the text string and put a '\' in front of all '\',
   // '(', or ')'.
   string::iterator itor2 = txt.begin ();
   for (; itor2 != txt.end (); ++itor2) {
      if ((*itor2 == '\\') || (*itor2 == '(') || (*itor2 == ')')) {
         itor2 = txt.insert (itor2, '\\');
         ++itor2;
      }
   }

   return new text (font, points (size), txt);
}

//
// make_ellipse
//    Create and return a pointer to an ellipse object initialized to
//    the given list of parameters.  Scan the parameter list for
//    validity and throw a syntax error if the number of parameters is
//    incorrect, or if a non-number is given for any argument.
//
object *interpreter::make_ellipse (parameters &command) {
   TRACE ('f', command);
   if (command.size () < 2 || command.size () > 3)
      throw runtime_error ("syntax error");

   // Pop the front two strings from the command list.  Try to convert
   // them to a double and set them as height and width respectively.
   // If an error is caught, throw a syntax error.
   double height, width;
   try {
      string temp1 = shift (command);
      string temp2 = shift (command);
      height = from_string<double> (temp1);
      width = from_string<double> (temp2);
   } catch (domain_error error) {
      throw runtime_error ("syntax error");
   }
   
   // Check if the command list is empty.  If so, set the thickness to
   // the default size of 2.0 points.  If not, pop the thickness
   // string.  Try to convert it to a double.  If any errors are caught,
   // throw a syntax error.
   double thick;
   if (command.empty ()) { thick = 2.0; }
   else {
      try {
         string temp = shift (command);
         thick = from_string<double> (temp);
      } catch (domain_error error) {
         throw runtime_error ("syntax error");
      }
   }
   
   return new ellipse (inches (height), inches (width), points (thick));
}

//
// make_circle
//    Create and return a pointer to a circle object initialized to the
//    given list of parameters.  Scan the parameter list for validity
//    and throw a syntax error if the number of parameters is incorrect,
//    or if a non-number is given for any argument.
//
object *interpreter::make_circle (parameters &command) {
   TRACE ('f', command);
   if (command.empty () || command.size () > 2)
      throw runtime_error ("syntax error");

   // Pop the diameter string from the command list.  Try to convert the
   // string to a double.  If any errors are caught, throw a syntax
   // error.
   double diameter;
   try {
      string temp = shift (command);
      diameter = from_string<double> (temp);
   } catch (domain_error error) {
      throw runtime_error ("syntax error");
   }
   
   // Check if the command list is empty.  If so, set the thickness to
   // the default size of 2.0 points.  If not, pop the thickness string
   // and try to convert it to a double.  If any errors are caught,
   // throw a syntax error.
   double thick;
   if (command.empty ()) { thick = 2.0; }
   else {
      try {
         string temp = shift (command);
         thick = from_string<double> (temp);
      } catch (domain_error error) {
         throw runtime_error ("syntax error");
      }
   }
   
   return new circle (inches (diameter), points (thick));
}

//
// make_polygon
//    Create and return a pointer to a polygon object initialized to the
//    given list of parameters.  Scan the parameter list for validity
//    and throw a syntax error if the number of parameters is incorrect,
//    or if a non-number is given for any argument.
//
object *interpreter::make_polygon (parameters &command) {
   TRACE ('f', command);
   if (command.size () <= 1) throw runtime_error ("syntax error");

   // Iterate through the command list.  Try to convert a pair of
   // strings to doubles.  Push the pair of doubles onto a coordinate
   // list.  If any errors are caught, throw a syntax error. A single
   // left over command is considered the thickness.  If no thickness
   // is given, set to the default of 2.0 points.  Try to convert to a
   // double as well and throw a syntax error for any errors caught.
   coordlist coords;
   double thick;
   while (!command.empty ()) {
      if (command.size () >= 2) {
         try {
            string tempx = shift (command);
            string tempy = shift (command);
            double x = from_string<double> (tempx);
            double y = from_string<double> (tempy);
            coords.push_back (xycoords (inches (y), inches (x)));
         } catch (domain_error error) {
            throw runtime_error ("syntax error");
         }
      }else if (command.size () == 1) {
         try {
            string temp = shift (command);
            thick = from_string<double> (temp);
         } catch (domain_error error) {
            throw runtime_error ("syntax error");
         }
      }else { thick = 2.0; }
   }
   
   return new polygon (coords, points (thick));
}

//
// make_rectangle
//    Create and return a pointer to a rectangle object initialized to
//    the  given list of parameters.  Scan the parameter list for
//    validity and throw a syntax error if the number of parameters is
//    incorrect, or if a non-number is given for any argument.
//
object *interpreter::make_rectangle (parameters &command) {
   TRACE ('f', command);
   if (command.size () < 2 || command.size () > 3)
      throw runtime_error ("syntax error");

   // Pop the first two string arguments from the command list.  Try to
   // convert them to double.  If any errors are caught, throw a syntax
   // error.
   double height, width;
   try {
      string temp1 = shift (command);
      string temp2 = shift (command);
      height = from_string<double> (temp1);
      width = from_string<double> (temp2);
   } catch (domain_error error) {
      throw runtime_error ("syntax error");
   }

   // Check if the command list is empty.  If so, set the thickness to
   // the default of 2.0 points.  If not, pop the thickness string from
   // the command list.  Try to convert the string to a double.  If any
   // errors are caught, throw a syntax error.
   double thick;
   if (command.empty ()) { thick = 2.0; }
   else {
      try {
         string temp = shift (command);
         thick = from_string<double> (temp);
      } catch (domain_error error) {
         throw runtime_error ("syntax error");
      }
   }
   
   return new rectangle (inches(height), inches(width), points(thick));
}

//
// make_square
//    Create and return a pointer to a square object initialized to the
//    given list of parameters.  Scan the parameter list for validity
//    and throw a syntax error if the number of parameters is incorrect,
//    or if a non-number is given for any argument.
//
object *interpreter::make_square (parameters &command) {
   TRACE ('f', command);
   if (command.empty () || command.size () > 2)
      throw runtime_error ("syntax error");

   // Pop the width string from the command list.  Try to convert the
   // string to a double.  If any errors are caught, throw a syntax
   // error.
   double width;
   try {
      string temp = shift (command);
      width = from_string<double> (temp);
   } catch (domain_error error) {
      throw runtime_error ("syntax error");
   }
   
   // Check if the command list is empty.  If so, set the thickness to
   // the default of 2.0 points.  If not, pop the thickness string from
   // the command list.  Try to convert the string to a double.  If any
   // errors are caught, throw a syntax error.
   double thick;
   if (command.empty ()) { thick = 2.0; }
   else {
      try {
         string temp = shift (command);
         thick = from_string<double> (temp);
      } catch (domain_error error) {
         throw runtime_error ("syntax error");
      }
   }
   
   return new square (inches (width), points (thick));
}

//
// make_line
//    Create and return a pointer to a line object initialized to the
//    given list of parameters.  Scan the parameter list for validity
//    and throw a syntax error if the number of parameters is incorrect,
//    or if a non-number is given for any argument.
//
object *interpreter::make_line (parameters &command) {
   TRACE ('f', command);
   if (command.empty () || command.size () > 2)
      throw runtime_error ("syntax error");

   // Pop the length string from the command list.  Try to convert the
   // string to a double.  If any errors are caught, throw a syntax
   // error.
   double length;
   try {
      string temp = shift (command);
      length = from_string<double> (temp);
   } catch (domain_error error) {
      throw runtime_error ("syntax error");
   }
   
   // Check if the command list is empty.  If so, set the thickness to
   // the default of 2.0 points.  If not, pop the thickness string from
   // the command list.  Try to convert the string to a double.  If any
   // errors are caught, throw a syntax error.
   double thick;
   if (command.empty ()) { thick = 2.0; }
   else {
      try {
         string temp = shift (command);
         thick = from_string<double> (temp);
      } catch (domain_error error) {
         throw runtime_error ("syntax error");
      }
   }
   
   return new line (inches (length), points (thick));
}
@


1.28
log
@-
@
text
@d131 1
a131 5
   // Throw a syntax error if the parameter list size is not two.
   // Otherwise, try to convert both parameters to doubles.  Catch
   // and throw any syntax errors.  Store the doubles into a
   // coordinate list.

@


1.27
log
@-
@
text
@d135 1
a135 2
   double x = 0;
   double y = 0;
d137 2
a138 11
   else {
      try {
         string temp = params.front ();
         x = from_string<double> (temp);
         temp = params.back ();
         y = from_string<double> (temp);
      } catch (domain_error error) {
         throw runtime_error ("syntax error");
      }
   }
   xycoords coords (inches (x), inches (y));
@


1.26
log
@-
@
text
@d136 2
a137 2
   double y n= 0;
   if (params.size() != 2) { throw runtime_error ("syntax error") }
@


1.25
log
@-
@
text
@d118 6
a123 3
   double x, y;
   try {
      if (params.size() == 3) {
d126 20
a146 7
      if (params.size() != 2) throw runtime_error ("syntax error");   
      string temp = params.front ();
      x = from_string<double> (temp);
      temp = params.back ();
      y = from_string<double> (temp);
   } catch (domain_error error) {
      throw runtime_error ("syntax error");
@


1.24
log
@-
@
text
@d125 4
a128 2
      x = from_string<double> (params.front());
      y = from_string<double> (params.back());
d130 1
a130 1
      throw runtime_error ("syntax error");;
@


1.23
log
@-
@
text
@d118 1
a118 1

d125 2
a126 3
      double x = from_string<double> (params.front());
      double y = from_string<double> (params.back());
      xycoords coords (inches (x), inches (y));
d130 1
@


1.22
log
@-
@
text
@d125 2
a126 2
      double x = from_string<double> (params.front);
      double y = from_string<double> (params.back);
@


1.21
log
@-
@
text
@d1 1
a1 1
/* $Id: interp.cpp,v 1.51 2011-02-14 21:29:51-08 dmfrank - $
d118 14
a131 7
   if (params.size() == 3) {
      angle = degrees (from_string<double> (params.back()));
      params.pop_back();
   }
   if (params.size() != 2) throw runtime_error ("syntax error");
   xycoords coords (inches (from_string<double> (params.front())),
                    inches (from_string<double> (params.back())));
@


1.20
log
@-
@
text
@a158 1
   double text_ypos = max_ypos - double (fontsize);
d164 1
a164 1
           << "0 " << text_ypos << " " << moveto << endl
@


1.19
log
@-
@
text
@d159 8
a166 8
   outfile << endl;
   outfile << "%%Page: " << pagenr << " " << pagenr << endl;
   outfile << page_xoffset << " " << page_yoffset
           << " translate" << endl;
   outfile << "/Courier findfont 10 scalefont setfont" << endl;
   outfile << "0 0 moveto (" << infilename << ":"
           << pagenr << ") show" << endl;

@


1.18
log
@-
@
text
@d1 1
a1 1
/* $Id: interp.cpp,v 1.50 2011-02-14 20:35:54-08 dmfrank - $
d87 1
a87 1
//    Looks up a function fased on a command and call
@


1.17
log
@-
@
text
@a257 1
      //     if (itor == end) break;
@


1.16
log
@-
@
text
@d1 1
a1 1
/* $Id: interp.cpp,v 1.37 2011-02-14 13:47:10-08 dmfrank - $
d56 1
a56 2
   objectmap::iterator end = objmap.end ();
   for (; itor != end; ++itor) {
d235 1
a235 2
   string::iterator end = font.end ();
   for (; itor != end; ++itor) {
d249 12
@


1.15
log
@-
@
text
@d1 1
a1 1
/* $Id: interp.cpp,v 1.34 2011-02-14 10:43:12-08 dmfrank - $
d116 1
a116 1
    object *thing = objmap[name];
d364 1
a364 1
            coords.push_back (xycoords (inches (x), inches (y)));
@


1.14
log
@-
@
text
@d228 1
a230 1
      temp = shift (command);
@


1.13
log
@-
@
text
@d224 1
a224 1
   string font, temp;
@


1.12
log
@-
@
text
@d143 1
a143 1
//    Writes the prolog comments for a new Postscript page.
d182 1
a182 1
//    Writes the epilog to a Postscript page.
d224 1
a224 1
   string font;
d226 1
a226 2
      string temp = shift (command);
      font = shift (command);
d230 1
a230 2
      string temp = shift (command);
      font = temp;
d232 1
@


1.11
log
@-
@
text
@d1 1
a1 1
/* $Id: interp.cpp,v 1.10 2011-02-14 11:30:39-08 dmfrank - $
d225 1
a225 1
/*   try {
d227 1
a228 1
      font = shift (command);
d234 1
a234 1
*/ 
d236 1
a236 1
/*   string::iterator itor = font.begin ();
d244 1
a244 1
*/ 
@


1.10
log
@-
@
text
@d1 1
a1 1
/* $Id: interp.cpp,v 1.9 2011-02-14 11:24:59-08 dmfrank - $
d215 2
a216 2
//   if (command.size () < 2)
   //    throw runtime_error ("syntax error");
d225 1
a225 1
   try {
d234 1
a234 1
   
@


1.9
log
@-
@
text
@d1 1
a1 1
/* $Id: interp.cpp,v 1.34 2011-02-14 10:43:12-08 dmfrank - $
d215 2
a216 2
   if (command.size () < 2)
      throw runtime_error ("syntax error");
@


1.8
log
@-
@
text
@d236 1
a236 1
   string::iterator itor = font.begin ();
d239 1
a239 1
      unsigned char ctemp = font.at (itor);
d244 1
a244 1
   
@


1.7
log
@-
@
text
@d239 1
a239 1
      unsigned char ctemp = *itor;
@


1.6
log
@-
@
text
@d131 2
a132 2
//    Takes care of accessing the factory.  Ends and starts a new page
//    for drawing.
d141 4
d155 4
d170 4
d180 4
d230 1
a231 1
      size = 12.0;
d236 2
a237 2
   string::const_iterator itor = font.begin ();
   string::const_iterator end = font.end ();
d240 1
a240 1
      double dtemp = ctemp -'0';
@


1.5
log
@-
@
text
@d1 1
a1 1
/* $Id: interp.cpp,v 0.4 2011-02-14 05:13:02-08 dmfrank - $
a57 1
      //object *obj = (*itor).second;
a59 1
 //  objmap.clear ();
@


1.4
log
@-
@
text
@d1 1
a1 1
/* $Id: interp.cpp,v 1.33 2011-02-14 05:07:56-08 dmfrank - $
d61 1
a61 1
   objmap.clear ();
@


1.3
log
@-
@
text
@d1 1
a1 1
/* $Id: interp.cpp,v 1.7 2011-02-14 00:14:26-08 dmfrank - $
d54 8
d201 1
a201 1
   if (command.size () < 2 || command.size () > 3)
d204 5
a208 4
   // Check the commands list size to know if the font size is given.
   // If not, set the font size to the default 12 points.  If so, pop
   // the text size string from the command list.  Throw a syntax error
   // if it contains non-numbers.  Convert the string to a double.
d210 19
a228 6
   if (command.size () == 2) { size = 12.0; }
   else {
      string size_as_str = shift (command);
      if (contain_nonnum (size_as_str))
         throw runtime_error ("syntax error");
      size = from_string<double> (size_as_str);
d231 2
a232 7
   // Pop the font style string from the command list.  Throw a syntax
   // error if it contains any numbers.
   string font = shift (command);
   if (contain_num (font))
      throw runtime_error ("syntax error");

   // Pop the text string from teh command list.
d234 4
a237 1
   
d253 13
a265 14
   // Pop the height string from the command list.  Throw a syntax error
   // if it contains any non-numbers.  Convert the string to a double.
   string height_as_str = shift (command);
   if (contain_nonnum (height_as_str))
      throw runtime_error ("syntax error");
   double height = from_string<double> (height_as_str);

   // Pop the width string from the command list.  Throw a syntax error
   // if it contains any non-numbers.  Convert the string to a double.
   string width_as_str = shift (command);
   if (contain_nonnum (width_as_str))
       throw runtime_error ("syntax error");
   double width = from_string<double> (height_as_str);

d267 3
a269 3
   // the default size of two points.  If not, pop the thickness
   // string.  Throw a syntax error if it contains any non-numbers.
   // Convert the string to a double.
d273 4
a276 2
      string thick_as_str = shift (command);
      if (contain_nonnum (thick_as_str))
d278 1
a278 1
      thick = from_string<double> (thick_as_str);
d296 8
a303 5
   // Pop the diameter string from the command list.  Throw a syntax
   // error if it contains any non-numbers.  Convert the string to a
   // double.
   string diam_as_str = shift (command);
   if (contain_nonnum (diam_as_str))
d305 2
a306 2
   double diameter = from_string<double> (diam_as_str);

d308 3
a310 2
   // the default size of two points.  If not, pop the thickness string.
   // Convert the string to a double.
d314 4
a317 2
      string thick_as_str = shift (command);
      if (contain_nonnum (thick_as_str))
d319 1
a319 1
      thick = from_string<double> (thick_as_str);
d336 6
a341 5
   // Iterate through the command list.  Store a pair of commands as
   // coordninates in a coordinate list.  A single left over command
   // is considered the thickness.  If no thickness is given, set to the
   // default of two points.  Throw a syntax error if any string
   // contains a non-number.  Convert all strings to doubles.
d346 7
a352 3
         string x_as_str = shift (command);
         string y_as_str = shift (command);
         if (contain_nonnum (x_as_str) || contain_nonnum (y_as_str))
d354 1
a354 3
         double x = from_string<double> (x_as_str);
         double y = from_string<double> (y_as_str);
         coords.push_back (xycoords (inches (x), inches (y)));
d356 4
a359 2
         string thick_as_str = shift (command);
         if (contain_nonnum (thick_as_str))
d361 1
a361 1
         thick = from_string<double> (thick_as_str);
d380 10
a389 6
   // Pop the height and width strings from the command list.  Throw a
   // syntax error if the strings contain non-numbers.  Convert both
   // strings to doubles.
   string height_as_str = shift (command);
   string width_as_str = shift (command);
   if (contain_nonnum (height_as_str) || contain_nonnum (width_as_str))
d391 1
a391 2
   double height = from_string<double> (height_as_str);
   double width = from_string<double> (width_as_str);
d394 3
a396 3
   // the default of two points.  If not, pop the thickness string from
   // the command list.  Throw a syntax error if the string contains any
   // non-numbers.  Conver the string to a double.
d400 4
a403 2
      string thick_as_str = shift (command);
      if (contain_nonnum (thick_as_str))
d405 1
a405 1
      thick = from_string<double> (thick_as_str);
d423 8
a430 5
   // Pop the width string from the command list.  Throw a syntax error
   // if the string contains non-numbers.  Convert the string to a
   // double.
   string width_as_str = shift (command);
   if (contain_nonnum (width_as_str))
d432 2
a433 2
   double width = from_string<double> (width_as_str);

d435 3
a437 3
   // the default of two points.  If not, pop the thickness string from
   // the command list.  Throw a syntax error if it contains any
   // non-numbers.  Convert the string to a double.
d441 4
a444 2
      string thick_as_str = shift (command);
      if (contain_nonnum (thick_as_str))
d446 1
a446 1
      thick = from_string<double> (thick_as_str);
d464 8
a471 5
   // Pop the length string from the command list.  Throw a syntax error
   // if the string contains a non-number.  Convert the string to a
   // double.
   string length_as_str = shift (command);
   if (contain_nonnum (length_as_str))
d473 2
a474 2
   double length = from_string<double> (length_as_str);

d476 3
a478 3
   // the default of two points.  If not, pop the thickness string from
   // the command list.  Throw a syntax error if it contains any
   // non-numbers.  Convert the string to a double.
d482 4
a485 2
      string thick_as_str = shift (command);
      if (contain_nonnum (thick_as_str))
d487 1
a487 1
      thick = from_string<double> (thick_as_str);
@


1.2
log
@-
@
text
@d1 1
a1 1
/* $Id: interp.cpp,v 1.1 2011-02-02 08:09:48-08 dmfrank - $
d3 7
a9 1
 */
d21 4
d47 4
d56 4
d61 5
d68 5
d80 4
d92 4
d102 5
d110 1
a110 1
   object *thing = objmap[name];
d123 5
d170 5
d183 8
d193 2
a194 2
   return new text ("", points(0), string());
}
d196 32
d230 31
a260 1
   return new ellipse (inches(0), inches(0), points(0));
d263 7
d272 24
a295 1
   return new circle (inches(0), points(0));
d298 7
d307 27
a333 1
   return new polygon (coordlist(), points(0));
d336 7
d345 27
a371 1
   return new rectangle (inches(0), inches(0), points(0));
d374 7
d383 25
a407 1
   return new square (inches(0), points(0));
d410 7
d419 25
a443 1
   return new line (inches(0), points(0));
a444 1

@


1.1
log
@-
@
text
@d1 3
a3 1
// $Id: interp.cc,v 1.1 2011-01-25 18:56:05-08 - - $
@
